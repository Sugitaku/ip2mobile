#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
import urllib
from datetime import datetime

DEBUG = False

class Docomo(object):
  def name(self):
    return 'docomo'

  def url(self):
    return 'http://www.nttdocomo.co.jp/service/imode/make/content/ip/'

  def run(self):
    content = urllib.urlopen(self.url()).read()
    n = self.name()
    return [(ip, n) for ip in re.findall(r'<li>(\d+\.\d+\.\d+\.\d+/\d+)[^<]*</li>', content, re.M)]

class DocomoSP(object):
  def name(self):
    return 'docomosp'

  def url(self):
    return 'http://www.nttdocomo.co.jp/service/developer/smart_phone/technical_info/etc/index.html'

  def run(self):
    content = urllib.urlopen(self.url()).read()
    n = self.name()
    pattern = '(\d+\.\d+\.\d+\.\d+/\d+)'
    result = re.findall(pattern, content, re.M)
    pattern = '(\d+\.\d+\.\d+\.\d+/\d+)\s*?\x81\x60\s*?(\d+\.\d+\.\d+\.\d+/\d+)'
    ip_ranges = re.findall(pattern, content, re.M)
    for ip_range in ip_ranges:
      pattern = '(\d+)\.(\d+)\.(\d+)\.(\d+)/(\d+)'
      ip = re.findall(pattern, ip_range[0], re.M) + re.findall(pattern, ip_range[1], re.M)
      if ip[0][4] == ip[1][4]:
        i = int(ip[0][4])/8-1
        start = int(ip[0][i])
        end = int(ip[1][i]) + 1
        for j in range(start, end):
          if i == 0:
            result.append(str(j) + '.' + ip[0][1] + '.' + ip[0][2] + '.' + ip[0][3] + '/' + ip[0][4])
          elif i == 1:
            result.append(ip[0][0] + '.' + str(j) + '.' + ip[0][2] + '.' + ip[0][3] + '/' + ip[0][4])
          elif i == 2:
            result.append(ip[0][0] + '.' + ip[0][1] + '.' + str(j) + '.' + ip[0][3] + '/' + ip[0][4])
          elif i == 3:
            result.append(ip[0][0] + '.' + ip[0][1] + '.' + ip[0][2] + '.' + str(j) + '/' + ip[0][4])
    return [(ip, n) for ip in list(set(result))]

class Ezweb(object):
  def name(self):
    return 'ezweb'

  def url(self):
    return 'http://www.au.kddi.com/ezfactory/tec/spec/ezsava_ip.html'

  def run(self):
    content = urllib.urlopen(self.url()).read()
    n = self.name()
    pattern = r'<td>\s*<div class="TableText">([\d\.]+)</div>\s*</td>\s+<td>\s*<div class="TableText">(/\d+)</div>\s*</td>'
    return [(ip + sn, n) for ip, sn in re.findall(pattern, content, re.M)]

class Softbank(object):
  def name(self):
    return 'softbank'

  def url(self):
    return 'http://creation.mb.softbank.jp/mc/tech/tech_web/web_ipaddress.html'

  def run(self):
    content = urllib.urlopen(self.url()).read()
    n = self.name()
    pattern = r'<th>(\d+\.\d+\.\d+\.\d+/\d+)</th>'
    return [(ip, n) for ip in re.findall(pattern, content, re.M)]

class AirHPhone(object):
  def name(self):
    return 'airhphone'

  def url(self):
    return 'http://www.willcom-inc.com/ja/service/contents_service/create/center_info/index.html'

  def run(self):
    content = urllib.urlopen(self.url()).read()
    n = self.name()
    pattern = '<td align="center" bgcolor="white"><font size="2">(\d+\.\d+\.\d+\.\d+/\d+)</font></td>'
    return [(ip, n) for ip in re.findall(pattern, content, re.M)]

class Emobile(object):
  def name(self):
    return 'emobile'

  def url(self):
    return 'http://developer.emnet.ne.jp/ipaddress.html'

  def run(self):
    content = urllib.urlopen(self.url()).read()
    n = self.name()
    pattern = r'<div align="center">(\d+\.\d+\.\d+\.\d+/\d+)</div>'
    return [(ip, n) for ip in re.findall(pattern, content, re.M)]

def get_cidr():
  classes = [Docomo, DocomoSP, Ezweb, Softbank, AirHPhone, Emobile]
  sources = []
  for carrier in classes:
    c = carrier()
    r = c.run()
    if DEBUG:
      print '** %s **' % c.name()
      for s in r:
        print '"%s"' % s[0]
    sources += r

  # convert cidr to ipaddress
  import socket, struct
  pat = '([\d\.]+)/(\d+)'
  ranges = []
  for s in sources:
    [(ip, bit)] = re.findall(pat, s[0], re.M)
    ipnum = struct.unpack('>L', socket.inet_aton(ip))[0]
    mask_ed = (1L << (32 - int(bit))) - 1
    mask_st = ~mask_ed
    ip_st = ipnum & mask_st
    ip_ed = ip_st | mask_ed
    ranges.append((ip_st, ip_ed, s[1]))

  # sort
  ranges.sort()

  # merge adjacent range
  preip_st = 0
  preip_ed = 0
  precarr = ''
  merge_st = False
  mranges = []
  i = 0
  while True:
    st = i
    try:
      n = ranges[i + 1]
      while ranges[i][1] + 1 == n[0] and \
            ranges[i][2] == n[2]:
        i += 1
        n = ranges[i + 1]
      mranges.append((ranges[st][0], ranges[i][1], ranges[st][2]))
      i += 1
    except IndexError, e:
      mranges.append((ranges[st][0], ranges[i][1], ranges[st][2]))
      break

  now = datetime.today()

  # output php source
  print """<?php
/*
This script is generated by scrape.py at %s.
http://svn.coderepos.org/share/lang/python/cidr-mobilejp/trunk/scrape.py
*/
function ip2mobile($ip) {
  $n = sprintf('%%u', ip2long($ip));
""" % now.strftime('%Y-%m-%d %H:%M:%S')
  output_php(mranges, 0, len(mranges) - 1, 2)
  print """  return 'pc';
}
?>
"""

def output_php(range, st, ed, ind):
  # print st, ed, "\n"
  if st > ed:
    return
  if st == ed:
    print ' ' * ind + 'if ($n >= %d && $n <= %d) {' % (
      range[st][0], range[st][1])
    print ' ' * ind + "  return '%s';" % range[st][2]
    print ' ' * ind + '}'
    return
  b = int((st + ed) / 2)
  print ' ' * ind + 'if ($n < %d) {' % range[b][0]
  output_php(range, st, b - 1, ind + 2)
  print ' ' * ind + '} else if ($n <= %d) {' % range[b][1]
  print ' ' * ind + "  return '%s';" % range[b][2]
  print ' ' * ind + '} else {'
  output_php(range, b + 1, ed, ind + 2)
  print ' ' * ind + '}'

if __name__ == '__main__':
  get_cidr()
